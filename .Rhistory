if(lambda3 == 0) Omega0 = apply(Omegas,1:2,mean) else {
s0 = apply(Omegas,1:2,mean)
log <- capture.output({
Omega0 = spcov_bcd(s0,lambda3)
})
# Omega0 = spcov(Omegas.old,s0,lambda,step.size=100)$Sigma
}
# record BCD iterations
count = count+1
# cat('iteration',count,'done \n')
if(count>100) {
cat('Omegas fail to converge for lam1 =',rho,'lam2 =',lambda2/K,'lam3 =',lambda3,'\n')
break
}
}
res = list(Omega0,Omegas)
names(res)=c("Omega0","Omegas")
return(res)
}
## block coordinate descending algorithm to calculation sparse covariance matrix
# following Wang's paper
spcov_bcd <- function(samp_cov,rho,initial=NULL) {
p = dim(samp_cov)[1]
if(is.null(initial)) Sigma=samp_cov+0.01*diag(p) else Sigma = initial
delta <- 0.0001
Sigma.old = matrix(0,p,p)
count2 = 0
while(max(abs(Sigma-Sigma.old)) > delta) {  # loop 1: Sigma convergence
Sigma.old <- Sigma
for(i in 1:p) {  # loop 2: update each row/column of Sigma
Omega11 <- solve(Sigma[-i,-i])
beta <- Sigma[-i,i]
S11 <- samp_cov[-i,-i]
s12 <- samp_cov[-i,i]
s22 <- samp_cov[i,i]
a <- t(beta)%*%Omega11%*%S11%*%Omega11%*%beta - 2*t(s12)%*%Omega11%*%beta + s22
if(rho == 0) gamma <- a else
if(c(a) < 10^-10) gamma <- a else
gamma <- (-1/(2*rho)+(1/(4*rho^2)+c(a)/rho)^0.5)
V <- Omega11%*%S11%*%Omega11/gamma + rho*Omega11
u <- t(s12)%*%Omega11/gamma
beta.old <- 0
while(max(abs(beta-beta.old)) > delta) {  # loop 3: off-diagonals convergence
beta.old <- beta
for(j in 1:(p-1)) {  # loop 4: each element
temp = u[j] - V[j,-j]%*%beta[-j]
beta[j] <- sign(temp)*max(0,abs(temp)-rho)/V[j,j]
}  # loop 4
}  # loop 3
Sigma[i,-i] <- t(beta)
Sigma[-i,i] <- beta
Sigma[i,i] <- gamma + t(beta)%*%Omega11%*%beta
}  # loop 2
# record spcov iterations
count2 = count2+1
if(count2>100) {
cat('Omega0 fails to converge for lam1 =',rho,'lam2 =',lambda2/K,'lam3 =',lambda3)
break
}
}  # loop 1
return(Sigma)
}  # end of function
myData <- rccSim(G = 1, clustSize = 10, p = 15, n = 100, overlap = 0.50, rho = 0.10)
myData <- rcm::rccSim(G = 1, clustSize = 10, p = 15, n = 100, overlap = 0.50, rho = 0.10)
microbenchmark::microbenchmark(rand_cov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0), randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001))
myData <- rcm::rccSim(G = 1, clustSize = 10, p = 15, n = 100, overlap = 0.50, rho = 0.10)
myRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
#' Random Covariance Model
#'
#' This function implements the Random Covariance Model (RCM) for joint estimation of
#' multiple sparse precision matrices. Optimization is conducted using block
#' coordinate descent.
#' @param x List of \eqn{K} data matrices each of dimension \eqn{n_k} x \eqn{p}.
#' @param lambda1 Non-negative scalar. Induces sparsity in subject-level matrices.
#' @param lambda2 Non-negative scalar. Induces similarity between subject-level matrices and group-level matrix.
#' @param lambda3 Non-negative scalar. Induces sparsity in group-level matrix.
#' @param delta Threshold for convergence.
#' @param max.iters Maximum number of iterations for block coordinate descent optimization.
#' @return A list of length 2 containing:
#' \enumerate{
#' \item Group-level precision matrix estimate (Omega0).
#' \item \eqn{p} x \eqn{p} x \eqn{K} array of \eqn{K} subject-level precision matrix estimates (Omegas).
#' }
#' @author
#' Lin Zhang and Andrew DiLernia
#'
#' @examples
#' # Generate data with 5 subjects, 15 variables for each subject,
#' # 100 observations for each variable for each subject,
#' # and 10% of differential connections
#' # within each group
#' myData <- rccSim(G = 1, clustSize = 5, p = 15, n = 100, rho = 0.10)
#'
#' # Analyze simulated data with RCM
#' result <- randCov(x = myData$simDat, lambda1 = 0.30, lambda2 = 0.10, lambda3 = 0.001, delta = 0.001)
#'
#' @export
#'
#' @references
#' Zhang, Lin, Andrew DiLernia, Karina Quevedo, Jazmin Camchong, Kelvin Lim, and Wei Pan.
#' "A Random Covariance Model for Bi-level Graphical Modeling with Application to Resting-state FMRI Data." 2019. https://arxiv.org/pdf/1910.00103.pdf
randCov <- function(x, lambda1, lambda2, lambda3 = 0,
delta = 0.001, max.iters = 100) {
# Sparse covariance optimization function
spcov_bcd <- function(samp_cov, rho, initial = NULL, lambda2, lambda3) {
p <- dim(samp_cov)[1]
if (is.null(initial)) {
Sigma <- samp_cov + 0.01 * diag(p)
} else {
Sigma <- initial
}
delta <- 1e-04
Sigma.old <- matrix(0, p, p)
count2 <- 0
while (max(abs(Sigma - Sigma.old)) > delta) {
# loop 1: Sigma convergence
Sigma.old <- Sigma
for (i in 1:p) {
# loop 2: update each row/column of Sigma
Omega11 <- solve(Sigma[-i, -i])
beta <- Sigma[-i, i]
S11 <- samp_cov[-i, -i]
s12 <- samp_cov[-i, i]
s22 <- samp_cov[i, i]
a <- t(beta) %*% Omega11 %*% S11 %*% Omega11 %*% beta - 2 * t(s12) %*% Omega11 %*% beta + s22
if (rho == 0) {
gamma <- a
} else if (c(a) < 10^-10) {
gamma <- a
} else {
gamma <- (-1 / (2 * rho) + (1 / (4 * rho^2) + c(a) / rho)^0.5)
}
V <- Omega11 %*% S11 %*% Omega11 / gamma + rho * Omega11
u <- t(s12) %*% Omega11 / gamma
beta.old <- 0
while (max(abs(beta - beta.old)) > delta) {
# loop 3: off-diagonals convergence
beta.old <- beta
for (j in 1:(p - 1)) {
# loop 4: each element
temp <- u[j] - V[j, -j] %*% beta[-j]
beta[j] <- sign(temp) * max(0, abs(temp) - rho) / V[j, j]
}  # loop 4
}  # loop 3
Sigma[i, -i] <- t(beta)
Sigma[-i, i] <- beta
Sigma[i, i] <- gamma + t(beta) %*% Omega11 %*% beta
}  # loop 2
# record spcov iterations
count2 <- count2 + 1
if (count2 > 100) {
cat("Omega0 fails to converge for lam1 =", rho, "lam2 =", lambda2 / K, "lam3 =", lambda3)
break
}
}  # loop 1
return(Sigma)
}  # end of function
# Inputs:
K <- length(x)
p <- dim(x[[1]])[2]
Sa <- sapply(x, cov, simplify = "array")
Sl <- lapply(x, cov)
# Initial values
Omega0 <- solve(apply(Sa, 1:2, mean) + diag(1, p) * 0.01)
Omegas <- sapply(Sl, function(x1) solve(x1 + diag(1, p) * 0.01), simplify = "array")
Omega0.old <- matrix(0, p, p)
Omegas.old <- array(0, c(p, p, K))
count <- 0
rho <- lambda1 / (1 + lambda2 / K)
# Start BCD algorithm
while (max(abs(Omega0 - Omega0.old)) > delta | max(abs(Omegas - Omegas.old)) > delta) {
# Exit if exceeds max.iters
if (count > max.iters) {
cat("Failed to converge for lambda1 =", lambda1, ", lambda2 =", lambda2, ", lambda3 =", lambda3,
"delta0 =", max(abs(Omega0 - Omega0.old)),
", deltaK =", max(abs(Omegas - Omegas.old)))
# Returning results
res <- list(Omega0, Omegas)
names(res) <- c("Omega0", "Omegas")
return(res)
}
# Record current Omega0 & Omegas
Omega0.old <- Omega0
Omegas.old <- Omegas
# 1st step:
sk <- sapply(Sl, function(x1) (solve(Omega0) * lambda2 / K + x1) / (1 + lambda2 / K), simplify = FALSE)
for (k in 1:K) {
Omegas[, , k] <- glasso::glasso(sk[[k]], rho, penalize.diagonal = TRUE)$wi
}
# 2nd step:
if (lambda3 == 0) {
Omega0 <- apply(Omegas, 1:2, mean)
} else {
s0 <- apply(Omegas, 1:2, mean)
log <- capture.output({
Omega0 <- spcov_bcd(s0, lambda3, lambda2 = lambda2, lambda3 = lambda3)
})
}
# Record BCD iterations
count <- count + 1
}
res <- list(Omega0, Omegas)
names(res) <- c("Omega0", "Omegas")
return(res)
}
myRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
bic_cal <- function(x, Omegas, Gk_est = NULL) {
#regular BIC
library(plyr)
nk = sapply(x,nrow)
S = sapply(x,cov,simplify="array")
p = dim(Omegas)[1]
K = length(x)
if(is.null(Gk_est)) Gk_est = (abs(Omegas) > 0.001) - array(diag(p),c(p,p,K))
nedges = apply(Gk_est,3,sum)/2
bic <- mapply(function(x1,x2,x3,x4) (x1-1)*sum(diag(x2%*%x3)) - x1*log(det(x3)) + x4*log(x1),
nk, alply(S,3),alply(Omegas,3),nedges+p)
return(sum(bic))
}
bic_cal(x = myData$simDat, Omegas = myRes$Omegas)
rcm::aicbic(x = myData$simDat, omegaks = myRes$Omegas)
rcm::aicbic(x = myData$simDat, omegaks = myRes$Omegas) / 10
rcm::aicbic(x = myData$simDat, omegaks = myRes$Omegas) / 10
bic_cal(x = myData$simDat, Omegas = myRes$Omegas)
rcm::aicbic(x = myData$simDat, omegaks = myRes$Omegas) / 100
bic_cal <- function(x, Omegas, Gk_est = NULL) {
#regular BIC
nk <- sapply(x,nrow)
S <- lapply(x, FUN = cov)
p <- dim(Omegas)[1]
K <- length(x)
if(is.null(Gk_est)) {
Gk_est <- (abs(Omegas) > 0.001) - array(diag(p),c(p,p,K))
}
nedges <- apply(Gk_est, MARGIN = 3, FUN = sum) / 2
bic <- mapply(FUN = function(x1,x2,x3,x4) {(x1-1)*sum(diag(x2%*%x3)) - x1*log(det(x3)) + x4*log(x1)},
nk, S, lapply(1:K, FUN = function(k){Omegas[, , k]}),nedges+p)
return(sum(bic))
}
bic_cal(x = myData$simDat, Omegas = myRes$Omegas)
myRes <- lapply(seq(0.03, 0.60, by = 0.03), FUN = function(lamb1){randCov(myData$simDat, lambda1 = lamb1, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)})
myRes <- lapply(seq(0.01, 1, by = 0.01), FUN = function(lamb1){randCov(myData$simDat, lambda1 = lamb1, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)})
sapply(myRes, FUN = function(res){bic_cal(x = myData$simDat, Omegas = res$Omegas)})
which.min(sapply(myRes, FUN = function(res){bic_cal(x = myData$simDat, Omegas = res$Omegas)}))
which.min(sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, Omegas = res$Omegas)$BIC}))
which.min(sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, Omegas = res$Omegas)}))
which.min(sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, omegaks = res$Omegas)$BIC}))
which.min(sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, omegaks = res$Omegas)[2]}))
plot(sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, omegaks = res$Omegas)[2]}))
plot(sapply(myRes, FUN = function(res){bic_cal(x = myData$simDat, Omegas = res$Omegas)}))
?rcm::aicbic
plot(sapply(myRes, FUN = function(res){bic_cal(x = myData$simDat, Omegas = res$Omegas)}))
plot(sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, omegaks = res$Omegas)}))
sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, omegaks = res$Omegas)})
sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, omegaks = res$Omegas)[1]})
plot(sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, omegaks = res$Omegas)[1]}))
plot(sapply(myRes, FUN = function(res){rcm::aicbic(x = myData$simDat, omegaks = res$Omegas)[2]}))
?bic
rcmMbic <- function(x, Omega0, Omegas, lambda2, G0_est = NULL, Gk_est = NULL) {
nk <- sapply(x, FUN = nrow)
S <- lapply(x, FUN = cov)
p <- dim(Omegas)[1]
K <- length(x)
if(is.null(Gk_est)) {Gk_est = (abs(Omegas) > 0.001) - array(diag(p),c(p,p,K))}
if(is.null(G0_est)) {G0_est = (abs(Omega0) > 0.001) - diag(p)}
nedges <- apply(Gk_est, MARGIN = 3, FUN = sum) / 2
df.r <- (nedges + p) / (1 + lambda2)
df.f <- (sum(G0_est) / 2 + p) * lambda2 / (1 + lambda2)
mbic <- mapply(FUN = function(x1,x2,x3) {(x1-1)*sum(diag(x2%*%x3)) - x1*log(det(x3))},
nk, S, lapply(1:K, FUN = function(k){Omegas[, , k]}))
return(sum(mbic) + (sum(df.r) + df.f) * log(sum(nk)))
}
rcmMbic(x = myData$simDat, Omega0 = myRes[[6]]$Omega0, Omegas = myRes[[6]]$Omegas, lambda2 = 0.01)
sapply(1:100, FUN = function(res){rcmMbic(x = myData$simDat, Omega0 = myRes[[res]]$Omega0, Omegas = myRes[[res]]$Omegas, lambda2 = 0.01)})
plot(sapply(1:100, FUN = function(res){rcmMbic(x = myData$simDat, Omega0 = myRes[[res]]$Omega0, Omegas = myRes[[res]]$Omegas, lambda2 = 0.01)}))
devtools::document()
?bic_cal
devtools::document()
?bic_cal
# Generate data
set.seed(1994)
myData <- rccSim(G = 1, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCM
rcmRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
# Calculate BIC for the RCM
bic_cal(x = myData$simDat, Omegas = rcmRes$Omegas)
?mbic_cal
# Generate data
set.seed(1994)
myData <- rccSim(G = 1, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCM
rcmRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
# Calculate modified BIC for the RCM
mbic_cal(x = myData$simDat, Omega0 = rcmRes$Omega0, Omegas = rcmRes$Omegas,
lambda2 = 0.01)
devtools::document()
?mbic_cal
?setdiff
# Demo file to run random covariance model for simulated data
library(rcm)
# library(abind)
# library(plyr)
# library(BDgraph)
# Simulating data ---------------------------------------------------------
# generate individual variants with rho=0.2 and errors [-0.1,0.1] for common edges
rm(list = ls())
p <- 100
# common graph
G <- diag(0,p)
G[1, 2:14] <- G[12, 15] <- G[13, 16] <- G[14, 17] <- G[17, 18] <- 1
G[1, 19] <- G[19, 20] <- G[19, 21] <- G[21, 22:23] <- G[23, 24] <- 1
G[1, 25] <- G[25, 26] <- 1
G[26, 27:33] <- G[33, 34:35] <- 1
G[26, 36] <- G[36, 37:39] <- G[38, 40] <- G[39, 41] <- 1
G[26, 42] <- G[42, 43:44] <- G[44,45] <- 1
G[26, 46] <- G[46, 47] <- G[47, 48] <- G[48, 49:52] <- G[52, 53] <- 1
G[26, 54] <- 1
G[54, 55:62] <- G[59, 63] <- G[60, 64] <- G[61, 65] <- G[62, 66] <- 1
G[54, 67] <- G[67, 68:72] <- 1
G[54, 73] <- G[73, 74:76] <- G[76, 77] <- 1
G[54, 78] <- 1
G[78, 79:82] <- G[81, 83] <- G[82, 84:85] <- 1
G[78, 86] <- 1
G[86, 87:92] <- G[90, 93] <- G[91, 94] <- G[92, 95:96] <- 1
G[86, 97] <- G[97, 98:99] <- G[99, 100] <- 1
temp <- diag(0.5, p) + G * matrix(runif(p * p, 0.5, 1) * sample(c(-1, 1), p * p, replace = TRUE), p, p)
temp2 <- temp + t(temp) + diag(rowSums(G + t(G)) / 2)
any(eigen(temp2, only.values = T)$values <= 0)
Omega0.true <- diag(diag(temp2)^-0.5) %*% temp2 %*% diag(diag(temp2)^-0.5)
# Add/subtract individual specific edges
A <- diag(0, p);
A[upper.tri(A)] <- 1;
A <- A-G;
ind.0 <- which(A == 1)
ind.1 <- which(G == 1)
K <- 8
Gk <- Omegas.true <- array(0, c(p, p, K))
dif.p <- 0.2
es <- 0.1
# Generating mechanism 1
for(k in 1:K) {
ind.ak <- sample(ind.0, round(sum(G) * dif.p))
ind.dk <- sample(ind.1, round(sum(G) * dif.p))
ind.sm <- setdiff(ind.1, ind.dk)
G.ak <- G.dk <- G.sm <- matrix(0, p, p)
G.ak[ind.ak] <- 1
G.dk[ind.dk] <- 1
G.sm[ind.sm] <- 1
temp.k = matrix(0, p, p)
while(any(eigen(temp.k)$values <= 0)) {
temp.ak <- G.ak * matrix(runif(p * p, 0.5, 1) * sample(c(-1, 1), p * p, replace = TRUE), p, p)
temp.dk <- G.dk * temp
temp.sm <- G.sm * matrix(runif(p * p, 0, es) * sample(c(-1, 1),p * p,replace = TRUE), p, p)
temp.k <- temp + t(temp) - temp.dk - t(temp.dk) + temp.ak + t(temp.ak) + temp.sm + t(temp.sm) +
diag(rowSums(G + t(G) + G.ak + t(G.ak) - G.dk - t(G.dk)) / 2)
}
Omegas.true[, , k] <- diag(diag(temp.k)^-0.5) %*% temp.k %*% diag(diag(temp.k)^-0.5)
Gk[,,k] <- G + G.ak -G.dk
cat(k,"is done \n")
}
G.true <- G
Gk.true <- Gk
n <- 50
sim.dat <- rep(list(NA),K)
for(k in 1:K) x[[k]] <- matrix(rnorm(n * p), n, p) %*% chol(solve(Omegas.true[, , k]))
# Analyzing data ----------------------------------------------------------
# parameters to tune: lambda1, lambda2, and lambda3
lam2.cand = 100 ; lam3.cand = 0.0001
lam1.cand = c(0.0002,0.0006,0.0008,seq(0.001,0.006,by=0.001),0.008,0.01,0.015,0.02)
lams.cand <- expand.grid(lam1.cand,lam2.cand,lam3.cand)
lam2.cand = 70 ; lam3.cand = 0.0001
lam1.cand = c(0.0002,0.0006,0.0008,seq(0.001,0.006,by=0.001),0.008,0.01,0.015,0.02)
lams.cand <- rbind(lams.cand,expand.grid(lam1.cand,lam2.cand,lam3.cand))
lam2.cand = 40 ; lam3.cand = 0.001
lam1.cand = c(0.0002,0.0006,0.0008,seq(0.001,0.006,by=0.001),0.008,0.01,0.015,0.02)
lams.cand <- rbind(lams.cand,expand.grid(lam1.cand,lam2.cand,lam3.cand))
colnames(lams.cand) <- c('lam1','lam2','lam3')
nlams <- nrow(lams.cand)
x <- sim.dat
K = length(x); p = ncol(x[[1]])
uptri.mat0 <- diag(0,p); uptri.mat0[upper.tri(diag(p))] <- 1
uptri.matk <- array(uptri.mat0,c(p,p,K))
Omega0.est <- array(NA,c(p,p,nlams))
Omegas.est <- array(NA,c(p,p,K,nlams))
bic.rc <- mbic.rc <- array(NA,nlams)
for(j in 1:nlams) {
# regularizing parameters
lam1 <- lams.cand[j,1]*(1+lams.cand[j,2])
lam2 <- lams.cand[j,2]*K;
lam3 <- lams.cand[j,3]
# estimation
est <- randCov(x,lam1,lam2,lam3)
Omega0 <- est$Omega0
Omegas <- est$Omegas
Omega0.est[,,j] <- Omega0.1
Omegas.est[,,,j] <- Omegas.1
# calculate BIC
bic.rc[j] <- bic_cal(x,Omegas)
mbic.rc[j] <- mbic_cal(x,Omega0,Omegas,lams.cand[j,2])
# keep track
if(j < nlams & lams.cand[j+1,2] != lams.cand[j,2]) cat('lam2 =',lams.cand[j,2],'is done \n')
}  # end of loop for all lambdas
Omega0.rc <- Omega0.est[,,which.min(mbic.rc)]
Omegas.rc <- Omegas.est[,,,which.min(mbic.rc)]
# Demo file to run random covariance model for simulated data
library(rcm)
# library(abind)
# library(plyr)
# library(BDgraph)
# Simulating data ---------------------------------------------------------
# generate individual variants with rho=0.2 and errors [-0.1,0.1] for common edges
rm(list = ls())
p <- 100
# common graph
G <- diag(0,p)
G[1, 2:14] <- G[12, 15] <- G[13, 16] <- G[14, 17] <- G[17, 18] <- 1
G[1, 19] <- G[19, 20] <- G[19, 21] <- G[21, 22:23] <- G[23, 24] <- 1
G[1, 25] <- G[25, 26] <- 1
G[26, 27:33] <- G[33, 34:35] <- 1
G[26, 36] <- G[36, 37:39] <- G[38, 40] <- G[39, 41] <- 1
G[26, 42] <- G[42, 43:44] <- G[44,45] <- 1
G[26, 46] <- G[46, 47] <- G[47, 48] <- G[48, 49:52] <- G[52, 53] <- 1
G[26, 54] <- 1
G[54, 55:62] <- G[59, 63] <- G[60, 64] <- G[61, 65] <- G[62, 66] <- 1
G[54, 67] <- G[67, 68:72] <- 1
G[54, 73] <- G[73, 74:76] <- G[76, 77] <- 1
G[54, 78] <- 1
G[78, 79:82] <- G[81, 83] <- G[82, 84:85] <- 1
G[78, 86] <- 1
G[86, 87:92] <- G[90, 93] <- G[91, 94] <- G[92, 95:96] <- 1
G[86, 97] <- G[97, 98:99] <- G[99, 100] <- 1
temp <- diag(0.5, p) + G * matrix(runif(p * p, 0.5, 1) * sample(c(-1, 1), p * p, replace = TRUE), p, p)
temp2 <- temp + t(temp) + diag(rowSums(G + t(G)) / 2)
any(eigen(temp2, only.values = T)$values <= 0)
Omega0.true <- diag(diag(temp2)^-0.5) %*% temp2 %*% diag(diag(temp2)^-0.5)
# Add/subtract individual specific edges
A <- diag(0, p);
A[upper.tri(A)] <- 1;
A <- A-G;
ind.0 <- which(A == 1)
ind.1 <- which(G == 1)
K <- 8
Gk <- Omegas.true <- array(0, c(p, p, K))
dif.p <- 0.2
es <- 0.1
# Generating mechanism 1
for(k in 1:K) {
ind.ak <- sample(ind.0, round(sum(G) * dif.p))
ind.dk <- sample(ind.1, round(sum(G) * dif.p))
ind.sm <- setdiff(ind.1, ind.dk)
G.ak <- G.dk <- G.sm <- matrix(0, p, p)
G.ak[ind.ak] <- 1
G.dk[ind.dk] <- 1
G.sm[ind.sm] <- 1
temp.k = matrix(0, p, p)
while(any(eigen(temp.k)$values <= 0)) {
temp.ak <- G.ak * matrix(runif(p * p, 0.5, 1) * sample(c(-1, 1), p * p, replace = TRUE), p, p)
temp.dk <- G.dk * temp
temp.sm <- G.sm * matrix(runif(p * p, 0, es) * sample(c(-1, 1),p * p,replace = TRUE), p, p)
temp.k <- temp + t(temp) - temp.dk - t(temp.dk) + temp.ak + t(temp.ak) + temp.sm + t(temp.sm) +
diag(rowSums(G + t(G) + G.ak + t(G.ak) - G.dk - t(G.dk)) / 2)
}
Omegas.true[, , k] <- diag(diag(temp.k)^-0.5) %*% temp.k %*% diag(diag(temp.k)^-0.5)
Gk[,,k] <- G + G.ak -G.dk
cat(k,"is done \n")
}
G.true <- G
Gk.true <- Gk
n <- 50
sim.dat <- rep(list(NA),K)
for(k in 1:K) {
sim.dat[[k]] <- matrix(rnorm(n * p), n, p) %*% chol(solve(Omegas.true[, , k]))
}
# Analyzing data ----------------------------------------------------------
# parameters to tune: lambda1, lambda2, and lambda3
lam2.cand = 100 ; lam3.cand = 0.0001
lam1.cand = c(0.0002,0.0006,0.0008,seq(0.001,0.006,by=0.001),0.008,0.01,0.015,0.02)
lams.cand <- expand.grid(lam1.cand,lam2.cand,lam3.cand)
lam2.cand = 70 ; lam3.cand = 0.0001
lam1.cand = c(0.0002,0.0006,0.0008,seq(0.001,0.006,by=0.001),0.008,0.01,0.015,0.02)
lams.cand <- rbind(lams.cand,expand.grid(lam1.cand,lam2.cand,lam3.cand))
lam2.cand = 40 ; lam3.cand = 0.001
lam1.cand = c(0.0002,0.0006,0.0008,seq(0.001,0.006,by=0.001),0.008,0.01,0.015,0.02)
lams.cand <- rbind(lams.cand,expand.grid(lam1.cand,lam2.cand,lam3.cand))
colnames(lams.cand) <- c('lam1','lam2','lam3')
nlams <- nrow(lams.cand)
x <- sim.dat
K = length(x); p = ncol(x[[1]])
uptri.mat0 <- diag(0,p); uptri.mat0[upper.tri(diag(p))] <- 1
uptri.matk <- array(uptri.mat0,c(p,p,K))
Omega0.est <- array(NA,c(p,p,nlams))
Omegas.est <- array(NA,c(p,p,K,nlams))
bic.rc <- mbic.rc <- array(NA,nlams)
for(j in 1:nlams) {
# regularizing parameters
lam1 <- lams.cand[j,1]*(1+lams.cand[j,2])
lam2 <- lams.cand[j,2]*K;
lam3 <- lams.cand[j,3]
# estimation
est <- randCov(x,lam1,lam2,lam3)
Omega0 <- est$Omega0
Omegas <- est$Omegas
Omega0.est[,,j] <- Omega0.1
Omegas.est[,,,j] <- Omegas.1
# calculate BIC
bic.rc[j] <- bic_cal(x,Omegas)
mbic.rc[j] <- mbic_cal(x,Omega0,Omegas,lams.cand[j,2])
# keep track
if(j < nlams & lams.cand[j+1,2] != lams.cand[j,2]) cat('lam2 =',lams.cand[j,2],'is done \n')
}  # end of loop for all lambdas
Omega0.rc <- Omega0.est[,,which.min(mbic.rc)]
Omegas.rc <- Omegas.est[,,,which.min(mbic.rc)]
