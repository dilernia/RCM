# Changing edge presence for floor(rho * E) pairs of vertices from group-level graph
if (floor(rho * sum(gks[, , k])) > 0) {
# Determining which %rho*100 of node pairs to change edge presence for
swaps <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:(p * (p - 1) / 2),
size = floor(rho * sum(gks[, , k]))), ], ncol = 2)
for (s in 1:nrow(swaps)) {
gks[, , k][swaps[s, 1], swaps[s, 2]] <- abs(gks[, , k][swaps[s, 1], swaps[s, 2]] - 1)
Omegaks[, , k][swaps[s, 1], swaps[s, 2]] <- ifelse(gks[, , k][swaps[s, 1], swaps[s, 2]] == 1,
runif(0.50, 1, n = 1) * sample(c(-1, 1), size = 1), 0)
}
}
# Making graph symmetric
gks[, , k] <- gks[, , k] + t(gks[, , k])
# Making matrix symmetric and positive definite
Omegaks[, , k] <- symmPosDef(Omegaks[, , k])
}
}
for (k in 1:K) {
# Generating subject data
simDat[[k]] <- mvtnorm::rmvnorm(n = n, sigma = solve(Omegaks[, , k]))
}
Omega0s[, , 2]
g0s[, , 2]
eShare
g0s[, , 1]
# Calculating total number of subjects
K <- ifelse(length(clustSize) == 1, G * clustSize, sum(clustSize))
# Cluster Networks --------------------------------------------------------
g0s <- array(0, c(p, p, G))
gks <- array(0, c(p, p, K))
Omega0s <- array(0, c(p, p, G))
Omegaks <- array(0, c(p, p, K))
if (length(clustSize) > 1) {
zgks <- c()
for (g in 1:length(clustSize)) {
zgks <- c(zgks, rep(g, clustSize[g]))
}
} else {
zgks <- sort(rep(1:G, clustSize))
}
simDat <- list()
# Manually generating cluster-level graphs and precision matrices
# Number of hubs
J <- floor(sqrt(p))
# Function for dividing entries by corresponding row sums to make positive definite
symmPosDef <- function(m, rs = rowSums(g0s[, , g])) {
m <- m + t(m)
smallE <- min(eigen(m)$values)
if (smallE <= 0) {
m <- m + diag(rep(abs(smallE) + 0.10 + 0.10, times = nrow(m)))
}
return(m)
}
# Determining edges to be shared across groups
numE <- p - J
q <- choose(p, 2)
numShare <- ifelse(type == "hub", floor(numE * overlap), floor(q * overlap))
eShare <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:q, size = numShare), ], ncol = 2)
shared <- sample(c(1, 0), size = nrow(eShare), prob = c(eprob, 1 - eprob))
# Different graphs if balanced clusters or not
balanced <- ifelse(length(clustSize) > 1, "_unbal", "")
# Generating group-level graphs and precision matrices
while (min(apply(Omega0s, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (g in 1:G) {
# Keeping cluster-level graphs constant across simulations
if (file.exists(paste0("graphs_", type, "_p", p, "_over", overlap, "_G",
G, balanced, ".rds")) == FALSE) {
g0s[, , g] <- matrix(0, nrow = p, ncol = p)
if(type == "hub") {
hubs <- split(sample.int(p, size = p, replace = FALSE), rep(1:J, ceiling(p / J))[1:p])
for (h in 1:J) {
for (v in hubs[[h]]) {
g0s[, , g][hubs[[h]][1], v] <- 1
}
}
} else if(type == "random") {
offInds <- lower.tri(g0s[, , g], diag = FALSE)
g0s[, , g][offInds] <- sample(c(1, 0), size = sum(offInds),
replace = TRUE, prob = c(eprob, 1 - eprob))
}
# Adding in numShare shared edges
for (e in 1:nrow(eShare)) {
g0s[, , g][eShare[e, 1], eShare[e, 2]] <- shared
}
# Saving graphs to keep constant across simulations
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
if (g == G) {
saveRDS(g0s, paste0("graphs_p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
} else {
g0s <- readRDS(paste0("graphs_", type, "p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
# Making graph triangular for precision matrix generation and storing row edge count
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
rwSum <- rowSums(g0s[, , g])
g0s[, , g][upper.tri(g0s[, , g], diag = T)] <- 0
Omega0s[, , g] <- g0s[, , g] * matrix(runif(n = p * p, min = 0.50, max = 1) * sample(c(1, -1),
size = p * p, replace = T), nrow = p, ncol = p)
if (g > 1) {
for (e in 1:nrow(eShare)) {
Omega0s[, , g][eShare[e, 1], eShare[e, 2]] <- Omega0s[, , g - 1][eShare[e, 1], eShare[e, 2]]
}
}
# Making matrix symmetric and positive definite
Omega0s[, , g] <- symmPosDef(Omega0s[, , g], rs = rwSum)
# Making graph full again, not just lower triangular
g0s[, , g] <- g0s[, , g] + t(g0s[, , g])
}
}
# Generating subject-level matrices
while (min(apply(Omegaks, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (k in 1:K) {
# Creating subject-level graph to be exactly same as group-level graph for now
gks[, , k] <- matrix(0, nrow = p, ncol = p)
gks[, , k][lower.tri(gks[, , k], diag = FALSE)] <- g0s[, , zgks[k]][lower.tri(g0s[, , zgks[k]],
diag = FALSE)]
# Forcing subject-level matrix to have similar value as group-level matrix
Omegaks[, , k] <- gks[, , k] * (Omega0s[, , zgks[k]] + matrix(rnorm(n = p * p, sd = esd),
nrow = p, ncol = p))
# Changing edge presence for floor(rho * E) pairs of vertices from group-level graph
if (floor(rho * sum(gks[, , k])) > 0) {
# Determining which %rho*100 of node pairs to change edge presence for
swaps <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:(p * (p - 1) / 2),
size = floor(rho * sum(gks[, , k]))), ], ncol = 2)
for (s in 1:nrow(swaps)) {
gks[, , k][swaps[s, 1], swaps[s, 2]] <- abs(gks[, , k][swaps[s, 1], swaps[s, 2]] - 1)
Omegaks[, , k][swaps[s, 1], swaps[s, 2]] <- ifelse(gks[, , k][swaps[s, 1], swaps[s, 2]] == 1,
runif(0.50, 1, n = 1) * sample(c(-1, 1), size = 1), 0)
}
}
# Making graph symmetric
gks[, , k] <- gks[, , k] + t(gks[, , k])
# Making matrix symmetric and positive definite
Omegaks[, , k] <- symmPosDef(Omegaks[, , k])
}
}
for (k in 1:K) {
# Generating subject data
simDat[[k]] <- mvtnorm::rmvnorm(n = n, sigma = solve(Omegaks[, , k]))
}
G = 2; clustSize = c(25, 25); p = 5; n = 150; overlap = 0.80; rho = 0; esd = 0.05; type = "random"; eprob = 0.50
# Calculating total number of subjects
K <- ifelse(length(clustSize) == 1, G * clustSize, sum(clustSize))
# Cluster Networks --------------------------------------------------------
g0s <- array(0, c(p, p, G))
gks <- array(0, c(p, p, K))
Omega0s <- array(0, c(p, p, G))
Omegaks <- array(0, c(p, p, K))
if (length(clustSize) > 1) {
zgks <- c()
for (g in 1:length(clustSize)) {
zgks <- c(zgks, rep(g, clustSize[g]))
}
} else {
zgks <- sort(rep(1:G, clustSize))
}
simDat <- list()
# Manually generating cluster-level graphs and precision matrices
# Number of hubs
J <- floor(sqrt(p))
# Function for dividing entries by corresponding row sums to make positive definite
symmPosDef <- function(m, rs = rowSums(g0s[, , g])) {
m <- m + t(m)
smallE <- min(eigen(m)$values)
if (smallE <= 0) {
m <- m + diag(rep(abs(smallE) + 0.10 + 0.10, times = nrow(m)))
}
return(m)
}
# Determining edges to be shared across groups
numE <- p - J
q <- choose(p, 2)
numShare <- ifelse(type == "hub", floor(numE * overlap), floor(q * overlap))
eShare <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:q, size = numShare), ], ncol = 2)
shared <- sample(c(1, 0), size = nrow(eShare), prob = c(eprob, 1 - eprob))
# Different graphs if balanced clusters or not
balanced <- ifelse(length(clustSize) > 1, "_unbal", "")
# Generating group-level graphs and precision matrices
while (min(apply(Omega0s, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (g in 1:G) {
# Keeping cluster-level graphs constant across simulations
if (file.exists(paste0("graphs_", type, "_p", p, "_over", overlap, "_G",
G, balanced, ".rds")) == FALSE) {
g0s[, , g] <- matrix(0, nrow = p, ncol = p)
if(type == "hub") {
hubs <- split(sample.int(p, size = p, replace = FALSE), rep(1:J, ceiling(p / J))[1:p])
for (h in 1:J) {
for (v in hubs[[h]]) {
g0s[, , g][hubs[[h]][1], v] <- 1
}
}
} else if(type == "random") {
offInds <- lower.tri(g0s[, , g], diag = FALSE)
g0s[, , g][offInds] <- sample(c(1, 0), size = sum(offInds),
replace = TRUE, prob = c(eprob, 1 - eprob))
}
# Adding in numShare shared edges
for (e in 1:nrow(eShare)) {
g0s[, , g][eShare[e, 1], eShare[e, 2]] <- shared
}
# Saving graphs to keep constant across simulations
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
if (g == G) {
saveRDS(g0s, paste0("graphs_p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
} else {
g0s <- readRDS(paste0("graphs_", type, "p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
# Making graph triangular for precision matrix generation and storing row edge count
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
rwSum <- rowSums(g0s[, , g])
g0s[, , g][upper.tri(g0s[, , g], diag = T)] <- 0
Omega0s[, , g] <- g0s[, , g] * matrix(runif(n = p * p, min = 0.50, max = 1) * sample(c(1, -1),
size = p * p, replace = T), nrow = p, ncol = p)
if (g > 1) {
for (e in 1:nrow(eShare)) {
Omega0s[, , g][eShare[e, 1], eShare[e, 2]] <- Omega0s[, , g - 1][eShare[e, 1], eShare[e, 2]]
}
}
# Making matrix symmetric and positive definite
Omega0s[, , g] <- symmPosDef(Omega0s[, , g], rs = rwSum)
# Making graph full again, not just lower triangular
g0s[, , g] <- g0s[, , g] + t(g0s[, , g])
}
}
# Generating subject-level matrices
while (min(apply(Omegaks, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (k in 1:K) {
# Creating subject-level graph to be exactly same as group-level graph for now
gks[, , k] <- matrix(0, nrow = p, ncol = p)
gks[, , k][lower.tri(gks[, , k], diag = FALSE)] <- g0s[, , zgks[k]][lower.tri(g0s[, , zgks[k]],
diag = FALSE)]
# Forcing subject-level matrix to have similar value as group-level matrix
Omegaks[, , k] <- gks[, , k] * (Omega0s[, , zgks[k]] + matrix(rnorm(n = p * p, sd = esd),
nrow = p, ncol = p))
# Changing edge presence for floor(rho * E) pairs of vertices from group-level graph
if (floor(rho * sum(gks[, , k])) > 0) {
# Determining which %rho*100 of node pairs to change edge presence for
swaps <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:(p * (p - 1) / 2),
size = floor(rho * sum(gks[, , k]))), ], ncol = 2)
for (s in 1:nrow(swaps)) {
gks[, , k][swaps[s, 1], swaps[s, 2]] <- abs(gks[, , k][swaps[s, 1], swaps[s, 2]] - 1)
Omegaks[, , k][swaps[s, 1], swaps[s, 2]] <- ifelse(gks[, , k][swaps[s, 1], swaps[s, 2]] == 1,
runif(0.50, 1, n = 1) * sample(c(-1, 1), size = 1), 0)
}
}
# Making graph symmetric
gks[, , k] <- gks[, , k] + t(gks[, , k])
# Making matrix symmetric and positive definite
Omegaks[, , k] <- symmPosDef(Omegaks[, , k])
}
}
for (k in 1:K) {
# Generating subject data
simDat[[k]] <- mvtnorm::rmvnorm(n = n, sigma = solve(Omegaks[, , k]))
}
# Calculating total number of subjects
K <- ifelse(length(clustSize) == 1, G * clustSize, sum(clustSize))
# Cluster Networks --------------------------------------------------------
g0s <- array(0, c(p, p, G))
gks <- array(0, c(p, p, K))
Omega0s <- array(0, c(p, p, G))
Omegaks <- array(0, c(p, p, K))
if (length(clustSize) > 1) {
zgks <- c()
for (g in 1:length(clustSize)) {
zgks <- c(zgks, rep(g, clustSize[g]))
}
} else {
zgks <- sort(rep(1:G, clustSize))
}
simDat <- list()
# Manually generating cluster-level graphs and precision matrices
# Number of hubs
J <- floor(sqrt(p))
# Function for dividing entries by corresponding row sums to make positive definite
symmPosDef <- function(m, rs = rowSums(g0s[, , g])) {
m <- m + t(m)
smallE <- min(eigen(m)$values)
if (smallE <= 0) {
m <- m + diag(rep(abs(smallE) + 0.10 + 0.10, times = nrow(m)))
}
return(m)
}
# Determining edges to be shared across groups
numE <- p - J
q <- choose(p, 2)
numShare <- ifelse(type == "hub", floor(numE * overlap), floor(q * overlap))
eShare <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:q, size = numShare), ], ncol = 2)
shared <- sample(c(1, 0), size = nrow(eShare), replace = TRUE, prob = c(eprob, 1 - eprob))
# Different graphs if balanced clusters or not
balanced <- ifelse(length(clustSize) > 1, "_unbal", "")
# Generating group-level graphs and precision matrices
while (min(apply(Omega0s, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (g in 1:G) {
# Keeping cluster-level graphs constant across simulations
if (file.exists(paste0("graphs_", type, "_p", p, "_over", overlap, "_G",
G, balanced, ".rds")) == FALSE) {
g0s[, , g] <- matrix(0, nrow = p, ncol = p)
if(type == "hub") {
hubs <- split(sample.int(p, size = p, replace = FALSE), rep(1:J, ceiling(p / J))[1:p])
for (h in 1:J) {
for (v in hubs[[h]]) {
g0s[, , g][hubs[[h]][1], v] <- 1
}
}
} else if(type == "random") {
offInds <- lower.tri(g0s[, , g], diag = FALSE)
g0s[, , g][offInds] <- sample(c(1, 0), size = sum(offInds),
replace = TRUE, prob = c(eprob, 1 - eprob))
}
# Adding in numShare shared edges
for (e in 1:nrow(eShare)) {
g0s[, , g][eShare[e, 1], eShare[e, 2]] <- shared
}
# Saving graphs to keep constant across simulations
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
if (g == G) {
saveRDS(g0s, paste0("graphs_p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
} else {
g0s <- readRDS(paste0("graphs_", type, "p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
# Making graph triangular for precision matrix generation and storing row edge count
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
rwSum <- rowSums(g0s[, , g])
g0s[, , g][upper.tri(g0s[, , g], diag = T)] <- 0
Omega0s[, , g] <- g0s[, , g] * matrix(runif(n = p * p, min = 0.50, max = 1) * sample(c(1, -1),
size = p * p, replace = T), nrow = p, ncol = p)
if (g > 1) {
for (e in 1:nrow(eShare)) {
Omega0s[, , g][eShare[e, 1], eShare[e, 2]] <- Omega0s[, , g - 1][eShare[e, 1], eShare[e, 2]]
}
}
# Making matrix symmetric and positive definite
Omega0s[, , g] <- symmPosDef(Omega0s[, , g], rs = rwSum)
# Making graph full again, not just lower triangular
g0s[, , g] <- g0s[, , g] + t(g0s[, , g])
}
}
# Generating subject-level matrices
while (min(apply(Omegaks, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (k in 1:K) {
# Creating subject-level graph to be exactly same as group-level graph for now
gks[, , k] <- matrix(0, nrow = p, ncol = p)
gks[, , k][lower.tri(gks[, , k], diag = FALSE)] <- g0s[, , zgks[k]][lower.tri(g0s[, , zgks[k]],
diag = FALSE)]
# Forcing subject-level matrix to have similar value as group-level matrix
Omegaks[, , k] <- gks[, , k] * (Omega0s[, , zgks[k]] + matrix(rnorm(n = p * p, sd = esd),
nrow = p, ncol = p))
# Changing edge presence for floor(rho * E) pairs of vertices from group-level graph
if (floor(rho * sum(gks[, , k])) > 0) {
# Determining which %rho*100 of node pairs to change edge presence for
swaps <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:(p * (p - 1) / 2),
size = floor(rho * sum(gks[, , k]))), ], ncol = 2)
for (s in 1:nrow(swaps)) {
gks[, , k][swaps[s, 1], swaps[s, 2]] <- abs(gks[, , k][swaps[s, 1], swaps[s, 2]] - 1)
Omegaks[, , k][swaps[s, 1], swaps[s, 2]] <- ifelse(gks[, , k][swaps[s, 1], swaps[s, 2]] == 1,
runif(0.50, 1, n = 1) * sample(c(-1, 1), size = 1), 0)
}
}
# Making graph symmetric
gks[, , k] <- gks[, , k] + t(gks[, , k])
# Making matrix symmetric and positive definite
Omegaks[, , k] <- symmPosDef(Omegaks[, , k])
}
}
for (k in 1:K) {
# Generating subject data
simDat[[k]] <- mvtnorm::rmvnorm(n = n, sigma = solve(Omegaks[, , k]))
}
# Centering generated data
simDat <- lapply(simDat, FUN = scale, scale = FALSE)
# Calculating total number of subjects
K <- ifelse(length(clustSize) == 1, G * clustSize, sum(clustSize))
# Cluster Networks --------------------------------------------------------
g0s <- array(0, c(p, p, G))
gks <- array(0, c(p, p, K))
Omega0s <- array(0, c(p, p, G))
Omegaks <- array(0, c(p, p, K))
if (length(clustSize) > 1) {
zgks <- c()
for (g in 1:length(clustSize)) {
zgks <- c(zgks, rep(g, clustSize[g]))
}
} else {
zgks <- sort(rep(1:G, clustSize))
}
simDat <- list()
# Manually generating cluster-level graphs and precision matrices
# Number of hubs
J <- floor(sqrt(p))
# Function for dividing entries by corresponding row sums to make positive definite
symmPosDef <- function(m, rs = rowSums(g0s[, , g])) {
m <- m + t(m)
smallE <- min(eigen(m)$values)
if (smallE <= 0) {
m <- m + diag(rep(abs(smallE) + 0.10 + 0.10, times = nrow(m)))
}
return(m)
}
# Determining edges to be shared across groups
numE <- p - J
q <- choose(p, 2)
numShare <- ifelse(type == "hub", floor(numE * overlap), floor(q * overlap))
eShare <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:q, size = numShare), ], ncol = 2)
shared <- sample(c(1, 0), size = nrow(eShare), replace = TRUE, prob = c(eprob, 1 - eprob))
# Different graphs if balanced clusters or not
balanced <- ifelse(length(clustSize) > 1, "_unbal", "")
# Generating group-level graphs and precision matrices
while (min(apply(Omega0s, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (g in 1:G) {
# Keeping cluster-level graphs constant across simulations
if (file.exists(paste0("graphs_", type, "_p", p, "_over", overlap, "_G",
G, balanced, ".rds")) == FALSE) {
g0s[, , g] <- matrix(0, nrow = p, ncol = p)
if(type == "hub") {
hubs <- split(sample.int(p, size = p, replace = FALSE), rep(1:J, ceiling(p / J))[1:p])
for (h in 1:J) {
for (v in hubs[[h]]) {
g0s[, , g][hubs[[h]][1], v] <- 1
}
}
} else if(type == "random") {
offInds <- lower.tri(g0s[, , g], diag = FALSE)
g0s[, , g][offInds] <- sample(c(1, 0), size = sum(offInds),
replace = TRUE, prob = c(eprob, 1 - eprob))
}
# Adding in numShare shared edges
for (e in 1:nrow(eShare)) {
g0s[, , g][eShare[e, 1], eShare[e, 2]] <- shared[e]
}
# Saving graphs to keep constant across simulations
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
if (g == G) {
saveRDS(g0s, paste0("graphs_p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
} else {
g0s <- readRDS(paste0("graphs_", type, "p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
# Making graph triangular for precision matrix generation and storing row edge count
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
rwSum <- rowSums(g0s[, , g])
g0s[, , g][upper.tri(g0s[, , g], diag = T)] <- 0
Omega0s[, , g] <- g0s[, , g] * matrix(runif(n = p * p, min = 0.50, max = 1) * sample(c(1, -1),
size = p * p, replace = T), nrow = p, ncol = p)
if (g > 1) {
for (e in 1:nrow(eShare)) {
Omega0s[, , g][eShare[e, 1], eShare[e, 2]] <- Omega0s[, , g - 1][eShare[e, 1], eShare[e, 2]]
}
}
# Making matrix symmetric and positive definite
Omega0s[, , g] <- symmPosDef(Omega0s[, , g], rs = rwSum)
# Making graph full again, not just lower triangular
g0s[, , g] <- g0s[, , g] + t(g0s[, , g])
}
}
# Generating subject-level matrices
while (min(apply(Omegaks, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (k in 1:K) {
# Creating subject-level graph to be exactly same as group-level graph for now
gks[, , k] <- matrix(0, nrow = p, ncol = p)
gks[, , k][lower.tri(gks[, , k], diag = FALSE)] <- g0s[, , zgks[k]][lower.tri(g0s[, , zgks[k]],
diag = FALSE)]
# Forcing subject-level matrix to have similar value as group-level matrix
Omegaks[, , k] <- gks[, , k] * (Omega0s[, , zgks[k]] + matrix(rnorm(n = p * p, sd = esd),
nrow = p, ncol = p))
# Changing edge presence for floor(rho * E) pairs of vertices from group-level graph
if (floor(rho * sum(gks[, , k])) > 0) {
# Determining which %rho*100 of node pairs to change edge presence for
swaps <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:(p * (p - 1) / 2),
size = floor(rho * sum(gks[, , k]))), ], ncol = 2)
for (s in 1:nrow(swaps)) {
gks[, , k][swaps[s, 1], swaps[s, 2]] <- abs(gks[, , k][swaps[s, 1], swaps[s, 2]] - 1)
Omegaks[, , k][swaps[s, 1], swaps[s, 2]] <- ifelse(gks[, , k][swaps[s, 1], swaps[s, 2]] == 1,
runif(0.50, 1, n = 1) * sample(c(-1, 1), size = 1), 0)
}
}
# Making graph symmetric
gks[, , k] <- gks[, , k] + t(gks[, , k])
# Making matrix symmetric and positive definite
Omegaks[, , k] <- symmPosDef(Omegaks[, , k])
}
}
for (k in 1:K) {
# Generating subject data
simDat[[k]] <- mvtnorm::rmvnorm(n = n, sigma = solve(Omegaks[, , k]))
}
# Centering generated data
simDat <- lapply(simDat, FUN = scale, scale = FALSE)
g0s[, , 2]
Omega0s[, , 2]
g0s[, , 1]
Omega0s[, , 1]
devtools::document()
