}
else {
floor(0.75 * (x))}})
# Drawing subsamples each of size b from data until
# N unique subsamples have been collected
keeper <- function(b, n) {
keepInds <- matrix(NA, nrow = b, ncol = N)
while (ncol(unique(keepInds, MARGIN = 2)) < N) {
for (s in 1:N) {
keepInds[, s] <- sort(sample(x = 1:n, size = b, replace = FALSE))
}
}
return(keepInds)
}
keepInds <- mapply(FUN = keeper, n = ns, b = bs, SIMPLIFY = FALSE)
# Reducing lambdas when possible
if (method == "GLasso") {
lambs <- data.frame(lambda1 = unique(lambs$lambda1), lambda2 = NA, lambda3 = NA)
} else if (method %in% c("FGL", "GGL")) {
lambs <- expand.grid(lambda1 = unique(lambs$lambda1), lambda2 = unique(lambs$lambda2), lambda3 = NA)
} else if (method %in% c("RCCM", "RCM")) {
lambs <- lambs
}
# Updating number of needed cores
if(is.null(ncores)) {
ncores <- 1
}
ncores <- min(c(ncores, nrow(lambs)))
# Implement select method for each of N bootstrap subsamples and obtaining networks
starNets <- lapply(1:N, FUN = function(i) {
# Obtaining ith bootstrap sample of data
subDats <- lapply(1:K, FUN = function(k) {
datf[[k]][keepInds[[k]][, i], ]})
# Running rccm method for bootstrap sample for each lambda combination in parallel if requested
if (ncores > 1) {
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "G", "K", "adj", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
} else {
nets <- lapply(1:nrow(lambs), FUN = function(t) {
tryCatch({
if (method == "RCCM") {
arrayRes <- rcm::rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100,
penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
})
}
return(nets)
})
i = 1
# Obtaining ith bootstrap sample of data
subDats <- lapply(1:K, FUN = function(k) {
datf[[k]][keepInds[[k]][, i], ]})
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
t = 1
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "G", "K", "adj", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "adj", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "adj", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
View(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "adj", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
t = 1
arrayRes <- randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
return(listRes)
}
parallel::stopCluster(cl)
View(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
return(listRes)
}
parallel::stopCluster(cl)
remove(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
return(listRes)
}
parallel::stopCluster(cl)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
})
return(listRes)
}
parallel::stopCluster(cl)
View(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
return(listRes)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
return(listRes)
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
return(listRes)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
return(listRes)
}
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
})
}
parallel::stopCluster(cl)
View(nets)
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 3, p = 5, n = 100, overlap = 0.50, rho = 0.10)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "RCM", G = 2)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "GLasso", G = 2)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "GLasso", G = 2, ncores = 3)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "FGL", G = 2)
View(optTune)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "FGL", G = 2, ncores = 3)
View(optTune)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "RCCM", G = 2)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "RCCM", G = 2, ncores = 3)
devtools::document()
?starsRccm
