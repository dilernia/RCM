Omega0.true <- diag(diag(temp2)^-0.5) %*% temp2 %*% diag(diag(temp2)^-0.5)
# Add/subtract individual specific edges
A <- diag(0, p)
A[upper.tri(A)] <- 1
A <- A-G
ind.0 <- which(A == 1)
ind.1 <- which(G == 1)
K <- 8
Gk <- Omegas.true <- array(0, c(p, p, K))
dif.p <- 0.2
es <- 0.1
# Generating mechanism 1
for(k in 1:K) {
ind.ak <- sample(ind.0, round(sum(G) * dif.p))
ind.dk <- sample(ind.1, round(sum(G) * dif.p))
ind.sm <- setdiff(ind.1, ind.dk)
G.ak <- G.dk <- G.sm <- matrix(0, p, p)
G.ak[ind.ak] <- 1
G.dk[ind.dk] <- 1
G.sm[ind.sm] <- 1
temp.k = matrix(0, p, p)
while(any(eigen(temp.k)$values <= 0)) {
temp.ak <- G.ak * matrix(runif(p * p, 0.5, 1) * sample(c(-1, 1), p * p, replace = TRUE), p, p)
temp.dk <- G.dk * temp
temp.sm <- G.sm * matrix(runif(p * p, 0, es) * sample(c(-1, 1),p * p,replace = TRUE), p, p)
temp.k <- temp + t(temp) - temp.dk - t(temp.dk) + temp.ak + t(temp.ak) + temp.sm + t(temp.sm) +
diag(rowSums(G + t(G) + G.ak + t(G.ak) - G.dk - t(G.dk)) / 2)
}
Omegas.true[, , k] <- diag(diag(temp.k)^-0.5) %*% temp.k %*% diag(diag(temp.k)^-0.5)
Gk[,,k] <- G + G.ak -G.dk
cat(k,"is done \n")
}
G.true <- G
Gk.true <- Gk
n <- 50
sim.dat <- rep(list(NA),K)
for(k in 1:K) {
sim.dat[[k]] <- matrix(rnorm(n * p), n, p) %*% chol(solve(Omegas.true[, , k]))
}
unlink('exampleSimulationRCM_cache', recursive = TRUE)
# Function for summarizing edge detection performances
performanceSummary <- function(Omegaks, Omegags, Omega0ks = Omegas.true, Omega0g = Omega0.true) {
# Calculating Precision Matrix Error, True Positive Rate, and False Positive Rates
subjSum <- sum(sapply(1:K, FUN = function(k){sum((adj(Omegaks[, , k]) +
adj(Omega0ks[, , k]))[lower.tri(Omega0ks[, , k], diag = FALSE)] == 2)}))
posskEdges <- sum(sapply(1:K, FUN = function(k){sum(adj(Omega0ks[, , k])[lower.tri(Omega0ks[, , k], diag = FALSE)] == 1)}))
TPRk <- subjSum / posskEdges
subjSum0 <- sum(sapply(1:K, FUN = function(k){sum((-1*adj(Omegaks[, , k]) +
adj(Omega0ks[, , k]))[lower.tri(Omega0ks[, , k], diag = FALSE)] == -1)}))
possk0s <- sum(sapply(1:K, FUN = function(k){sum(adj(Omega0ks[, , k])[lower.tri(Omega0ks[, , k], diag = FALSE)] == 0)}))
FPRk <- subjSum0 / possk0s
PrecisionK <- subjSum / (subjSum + subjSum0)
F1k <- 2*(PrecisionK*TPRk) / (PrecisionK + TPRk)
grpSum <- sum((adj(Omegags) + adj(Omega0g))[lower.tri(Omega0g, diag = FALSE)] == 2)
possgEdges <- sum(sapply(1:G, FUN = function(g){sum(adj(Omega0g)[lower.tri(Omega0g, diag = FALSE)] == 1)}))
TPRg <- grpSum / possgEdges
grpSum0 <- sum((-1*adj(Omegags) + adj(Omega0g))[lower.tri(Omega0g, diag = FALSE)] == -1)
possg0s <- sum(adj(Omega0g)[lower.tri(Omega0g, diag = FALSE)] == 0)
PrecisionG <- grpSum / (grpSum + grpSum0)
F1g <- 2*(PrecisionG*TPRg) / (PrecisionG + TPRg)
FPRg <- grpSum0 / possg0s
return(data.frame(TPRk = TPRk, FPRk = FPRk,
PrecisionK = PrecisionK, F1k = F1k,
TPRg = TPRg, FPRg = FPRg, PrecisionG = PrecisionG, F1g = F1g))
}
performanceSummary(Omegaks = Omegas.bic, Omegag = Omega0.bic) %>%
knitr::kable(digits = 3, row.names = F) %>% kable_styling(bootstrap_options = c("hover", "responsive"))
K <- dim(Omegas.true)[3]
unlink('exampleSimulationRCM_cache', recursive = TRUE)
unlink('exampleSimulationRCM_cache', recursive = TRUE)
remove.packages('dilernia/rcm')
remove.packages('rcm')
unlink('docs/exampleSimulationRCCM_cache', recursive = TRUE)
unlink('docs/exampleSimulation_cache', recursive = TRUE)
unlink('docs/exampleSimulationRCCM_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, fig.align="center",
message = F, warning = F)
# Install version of package used for Biostatistics submission
if("rcm" %in% installed.packages() == FALSE) {
devtools::install_github("dilernia/rcm@biostatistics")
}
# Load rcm package
library(rcm)
# Loading other packages
library(tidyverse, quietly = T)
library(kableExtra, quietly = T)
# Display help file
?rccSim
# Simulate data
set.seed(1994)
G <- 2
p <- 10
stN <- 10
myData <- rccSim(G = G, clustSize = 20, p = p, n = 177, overlap = 0.20, rho = 0.10)
# Standardizing data
myData$simDat <- lapply(myData$simDat, FUN = scale)
# Display help file
?cvTune
# Find optimal tuning parameter set using 5-fold CV
optTuneCV <- cvTune(x = myData$simDat, G = G, lambs = lambdas,
methods = c("RCCM", "GGL", "GLasso"), folds = 5)
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(1000, 3000, 5000), lambda3 = 20)
# Display help file
?cvTune
# Find optimal tuning parameter set using 5-fold CV
optTuneCV <- cvTune(x = myData$simDat, G = G, lambs = lambdas,
methods = c("RCCM", "GGL", "GLasso"), folds = 5)
unlink('docs/exampleSimulationRCCM_cache', recursive = TRUE)
unlink('docs/exampleSimulationRCCM_cache', recursive = TRUE)
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
remove.packages('rcm')
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, fig.align="center",
message = F, warning = F)
# Install package
if("rcm" %in% installed.packages() == FALSE) {
devtools::install_github("dilernia/rcm")
}
# Load rcm package
library(rcm)
# Loading other packages
library(tidyverse, quietly = T)
library(kableExtra, quietly = T)
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
?rccm::bic_cal
?rccm::mbic_cal
devtools::document()
bic_cal <- function(x, Omegas, Gk_est = NULL) {
nk <- sapply(x, FUN = nrow)
S <- lapply(x, FUN = cov)
p <- dim(Omegas)[1]
K <- length(x)
if(is.null(Gk_est)) {
Gk_est <- (abs(Omegas) > 0.001) - array(diag(p),c(p,p,K))
}
nedges <- apply(Gk_est, MARGIN = 3, FUN = sum) / 2
bic <- mapply(FUN = function(x1, x2, x3, x4) {(x1 - 1) * sum(diag(x2 %*% x3)) - x1 * log(det(x3)) + x4 * log(x1)},
nk, S, lapply(1:K, FUN = function(k){Omegas[, , k]}), nedges + p)
return(sum(bic))
}
bic_cal2 <- function(x, Omegas, Gk_est = NULL) {
nk <- sapply(x, nrow)
S <- lapply(x, cov, simplify="array")
p <- dim(Omegas)[1]
K <- length(x)
if(is.null(Gk_est)) {
Gk_est <- (round(Omegas,3) != 0) - array(diag(p), c(p, p, K))
}
nedges <- apply(Gk_est, 3, sum) / 2
bic <- mapply(function(x1, x2, x3, x4) {
(x1 - 1) * sum(diag(x2 %*% x3)) - x1 * log(det(x3)) + x4 * log(x1)},
nk, S, lapply(1:K, FUN = function(k){Omegas[, , k]}), nedges + p)
return(sum(bic))
}
myData <- rccm::rccSim(G = 1, clustSize = 10)
bic_cal(myData$simDat, myData$Omegaks)
bic_cal2(myData$simDat, myData$Omegaks)
bic_cal2 <- function(x, Omegas, Gk_est = NULL) {
nk <- sapply(x, nrow)
S <- lapply(x, cov)
p <- dim(Omegas)[1]
K <- length(x)
if(is.null(Gk_est)) {
Gk_est <- (round(Omegas,3) != 0) - array(diag(p), c(p, p, K))
}
nedges <- apply(Gk_est, 3, sum) / 2
bic <- mapply(function(x1, x2, x3, x4) {
(x1 - 1) * sum(diag(x2 %*% x3)) - x1 * log(det(x3)) + x4 * log(x1)},
nk, S, lapply(1:K, FUN = function(k){Omegas[, , k]}), nedges + p)
return(sum(bic))
}
bic_cal(myData$simDat, myData$Omegaks)
bic_cal2(myData$simDat, myData$Omegaks)
mbic_cal <- function(x, Omega0, Omegas, lambda2, G0_est = NULL, Gk_est = NULL) {
nk <- sapply(x, FUN = nrow)
S <- lapply(x, FUN = cov)
p <- dim(Omegas)[1]
K <- length(x)
if(is.null(Gk_est)) {Gk_est = (abs(Omegas) > 0.001) - array(diag(p),c(p,p,K))}
if(is.null(G0_est)) {G0_est = (abs(Omega0) > 0.001) - diag(p)}
nedges <- apply(Gk_est, MARGIN = 3, FUN = sum) / 2
df.r <- (nedges + p) / (1 + lambda2)
df.f <- (sum(G0_est) / 2 + p) * lambda2 / (1 + lambda2)
mbic <- mapply(FUN = function(x1,x2,x3) {(x1-1)*sum(diag(x2%*%x3)) - x1*log(det(x3))},
nk, S, lapply(1:K, FUN = function(k){Omegas[, , k]}))
return(sum(mbic) + (sum(df.r) + df.f) * log(sum(nk)))
}
mbic_cal2 <- function(x,Omega0,Omegas,lambda2,G0_est=NULL,Gk_est=NULL) {
# modified BIC
library(plyr)
nk = sapply(x,nrow)
S = sapply(x,cov,simplify="array")
p = dim(Omegas)[1]
K = length(x)
if(is.null(Gk_est)) Gk_est = (round(Omegas,3) != 0) - array(diag(p),c(p,p,K))
if(is.null(G0_est)) G0_est = (round(Omega0,3) != 0) - diag(p)
nedges = apply(Gk_est,3,sum)/2
# tmp = lambda2/nk
df.r <- (nedges+p)/(1+lambda2)
df.f <- (sum(G0_est)/2+p) *lambda2/(1+lambda2)
mbic <- mapply(function(x1,x2,x3) (x1-1)*sum(diag(x2%*%x3)) - x1*log(det(x3)), nk, alply(S,3),alply(Omegas,3))
return( sum(mbic) + (sum(df.r)+df.f)*log(sum(nk)) )
}
mbic_cal(myData$simDat, myData$Omegaks)
mbic_cal(myData$simDat, myData$Omega0s, myData$Omegaks)
mbic_cal(myData$simDat, myData$Omega0s[, , 1], myData$Omegaks)
mbic_cal(myData$simDat, myData$Omega0s[, , 1], myData$Omegaks, lambda2 = 0.01)
mbic_cal2(myData$simDat, myData$Omega0s[, , 1], myData$Omegaks, lambda2 = 0.01)
devtools::document()
remove.packages('rcm')
devtools::install_github('dilernia/rcm')
devtools::document()
# function to calculate regular BIC and modified BIC
bic_cal2 <- function(x,Omegas,Gk_est=NULL) {
#regular BIC
library(plyr)
nk = sapply(x,nrow)
S = sapply(x,cov,simplify="array")
p = dim(Omegas)[1]
K = length(x)
if(is.null(Gk_est)) Gk_est = (round(Omegas,3) != 0) - array(diag(p),c(p,p,K))
nedges = apply(Gk_est,3,sum)/2
bic <- mapply(function(x1,x2,x3,x4) (x1-1)*sum(diag(x2%*%x3)) - x1*log(det(x3)) + x4*log(x1),
nk, alply(S,3),alply(Omegas,3),nedges+p)
return(sum(bic))
}
mbic_cal2 <- function(x,Omega0,Omegas,lambda2,G0_est=NULL,Gk_est=NULL) {
# modified BIC
library(plyr)
nk = sapply(x,nrow)
S = sapply(x,cov,simplify="array")
p = dim(Omegas)[1]
K = length(x)
if(is.null(Gk_est)) Gk_est = (round(Omegas,3) != 0) - array(diag(p),c(p,p,K))
if(is.null(G0_est)) G0_est = (round(Omega0,3) != 0) - diag(p)
nedges = apply(Gk_est,3,sum)/2
# tmp = lambda2/nk
df.r <- (nedges+p)/(1+lambda2)
df.f <- (sum(G0_est)/2+p) *lambda2/(1+lambda2)
mbic <- mapply(function(x1,x2,x3) (x1-1)*sum(diag(x2%*%x3)) - x1*log(det(x3)), nk, alply(S,3),alply(Omegas,3))
return( sum(mbic) + (sum(df.r)+df.f)*log(sum(nk)) )
}
#' BIC for RCM
#'
#' This function calculates the BIC for the random covariance model (RCM)
#' @param x List of \eqn{K} data matrices each of dimension \eqn{n_k} x \eqn{p}.
#' @param Omegas \eqn{p} x \eqn{p} x \eqn{K} array of \eqn{K} number of estimated subject-level precision matrices.
#' @param Gk_est \eqn{p} x \eqn{p} x \eqn{K} array of \eqn{K} number of estimated subject-level networks.
#' @return Numeric BIC value
#'
#' @author
#' Lin Zhang
#'
#' @examples
#' # Generate data
#' set.seed(1994)
#' myData <- rccSim(G = 1, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
#'
#' # Analyze with RCM
#' rcmRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
#'
#' # Calculate BIC for the RCM
#' bic_cal(x = myData$simDat, Omegas = rcmRes$Omegas)
#'
#' @export
bic_cal <- function(x, Omegas, Gk_est = NULL) {
nk <- sapply(x, FUN = nrow)
S <- lapply(x, FUN = cov)
p <- dim(Omegas)[1]
K <- length(x)
if(is.null(Gk_est)) {
Gk_est <- (round(Omegas,3) != 0) - array(diag(p), c(p, p, K))
}
nedges <- apply(Gk_est, MARGIN = 3, FUN = sum) / 2
bic <- mapply(FUN = function(x1, x2, x3, x4) {(x1 - 1) * sum(diag(x2 %*% x3)) - x1 * log(det(x3)) + x4 * log(x1)},
nk, S, lapply(1:K, FUN = function(k){Omegas[, , k]}), nedges + p)
return(sum(bic))
}
#' Modified BIC for RCM
#'
#' This function calculates the modified BIC for the random covariance model (RCM)
#' @param x List of \eqn{K} data matrices each of dimension \eqn{n_k} x \eqn{p}.
#' @param Omega0 \eqn{p} x \eqn{p} group-level precision matrix estimate.
#' @param Omegas \eqn{p} x \eqn{p} x \eqn{K} array of \eqn{K} number of estimated subject-level precision matrices.
#' @param lambda2 Non-negative scalar. Induces similarity between subject-level matrices and group-level matrix.
#' @param G0_est \eqn{p} x \eqn{p} group-level network estimate.
#' @param Gk_est \eqn{p} x \eqn{p} x \eqn{K} array of \eqn{K} number of estimated subject-level networks.
#' @return Numeric Modified BIC value
#'
#' @author
#' Lin Zhang
#'
#' @examples
#' # Generate data
#' set.seed(1994)
#' myData <- rccSim(G = 1, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
#'
#' # Analyze with RCM
#' rcmRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
#'
#' # Calculate modified BIC for the RCM
#' mbic_cal(x = myData$simDat, Omega0 = rcmRes$Omega0, Omegas = rcmRes$Omegas,
#'          lambda2 = 0.01)
#'
#' @export
mbic_cal <- function(x, Omega0, Omegas, lambda2, G0_est = NULL, Gk_est = NULL) {
nk <- sapply(x, FUN = nrow)
S <- lapply(x, FUN = cov)
p <- dim(Omegas)[1]
K <- length(x)
if(is.null(Gk_est)) {Gk_est = (round(Omegas,3) != 0) - array(diag(p),c(p,p,K))}
if(is.null(G0_est)) { G0_est = (round(Omega0,3) != 0) - diag(p)}
nedges <- apply(Gk_est, MARGIN = 3, FUN = sum) / 2
df.r <- (nedges + p) / (1 + lambda2)
df.f <- (sum(G0_est) / 2 + p) * lambda2 / (1 + lambda2)
mbic <- mapply(FUN = function(x1,x2,x3) {(x1-1)*sum(diag(x2%*%x3)) - x1*log(det(x3))},
nk, S, lapply(1:K, FUN = function(k){Omegas[, , k]}))
return(sum(mbic) + (sum(df.r) + df.f) * log(sum(nk)))
}
?rcm::mbic_cal
# Generate data
set.seed(1994)
myData <- rccSim(G = 1, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCM
rcmRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
# Calculate modified BIC for the RCM
mbic_cal(x = myData$simDat, Omega0 = rcmRes$Omega0, Omegas = rcmRes$Omegas,
lambda2 = 0.01)
library(rcm)
# Generate data
set.seed(1994)
myData <- rccSim(G = 1, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCM
rcmRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
# Calculate modified BIC for the RCM
mbic_cal(x = myData$simDat, Omega0 = rcmRes$Omega0, Omegas = rcmRes$Omegas,
lambda2 = 0.01)
library(rccm)
# Generate data
set.seed(1994)
myData <- rccSim(G = 1, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCM
rcmRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
# Calculate modified BIC for the RCM
mbic_cal(x = myData$simDat, Omega0 = rcmRes$Omega0, Omegas = rcmRes$Omegas,
lambda2 = 0.01)
# Generate data
set.seed(1994)
myData <- rccSim(G = 1, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCM
rcmRes <- randCov(myData$simDat, lambda1 = 0.01, lambda2 = 0.01, lambda3 = 0, delta = 0.0001)
# Calculate modified BIC for the RCM
mbic_cal2(x = myData$simDat, Omega0 = rcmRes$Omega0, Omegas = rcmRes$Omegas,
lambda2 = 0.01)
remove.packages('rcm')
devtools::document()
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
devtools::document()
bic_cal < - function(x, Omegas, Gk_est=NULL) {
#regular BIC
nk = sapply(x, nrow)
S = sapply(x, cov, simplify="array")
p = dim(Omegas)[1]
K = length(x)
if(is.null(Gk_est)) Gk_est = (round(Omegas, 3) != 0) - array(diag(p), c(p, p, K))
nedges = apply(Gk_est, 3, sum) / 2
bic < - mapply(function(x1, x2, x3, x4) (x1 - 1) * sum(diag(x2 %*% x3)) - x1 * log(det(x3)) + x4 * log(x1),
nk, plyr::alply(S, 3), plyr::alply(Omegas, 3), nedges + p)
return(sum(bic))
}
devtools::document()
remove.packages('rcm')
devtools::install_github('dilernia/rcm')
?rccm::randCov
# Generate data with 5 subjects, 15 variables for each subject,
# 100 observations for each variable for each subject,
# and 10% of differential connections
# within each group
myData <- rccm::rccSim(G = 1, clustSize = 5, p = 15, n = 100, rho = 0.10)
# Analyze simulated data with RCM
result <- rcm::randCov(x = myData$simDat, lambda1 = 0.30, lambda2 = 0.10, lambda3 = 0.001)
rcm::bic_cal(x = myData$simDat, Omegas = result$Omegas)
rcm::mbic_cal(x = myData$simDat, Omegas = result$Omegas)
rcm::mbic_cal(x = myData$simDat, Omegas = result$Omegas, Omega0 = result$Omega0[, , 1])
rcm::mbic_cal(x = myData$simDat, Omegas = result$Omegas, Omega0 = result$Omega0)
rcm::mbic_cal(x = myData$simDat, Omegas = result$Omegas, Omega0 = result$Omega0, lambda2 = 0.01)
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
# file to specify graphs G and data for simulation study
# generate individual variants with rho=0.2 and errors [-0.1,0.1] for common edges
rm(list=ls())
p = 100
# common graph
G = diag(0,p)
G[1,2:14] <- G[12,15] <- G[13,16] <- G[14,17] <- G[17,18] <- 1
G[1,19] <- G[19,20] <- G[19,21] <- G[21,22:23] <- G[23,24] <- 1
G[1,25] <- G[25,26] <- 1
G[26,27:33] <- G[33,34:35] <- 1
G[26,36] <- G[36,37:39] <- G[38,40] <- G[39,41] <- 1
G[26,42] <- G[42,43:44] <- G[44,45] <- 1
G[26,46] <- G[46,47] <- G[47,48] <- G[48,49:52] <- G[52,53] <- 1
G[26,54] <- 1
G[54,55:62] <- G[59,63] <- G[60,64] <- G[61,65] <- G[62,66] <- 1
G[54,67] <- G[67,68:72] <- 1
G[54,73] <- G[73,74:76] <- G[76,77] <- 1
G[54,78] <- 1
G[78,79:82] <- G[81,83] <- G[82,84:85] <- 1
G[78,86] <- 1
G[86,87:92] <- G[90,93] <- G[91,94] <- G[92,95:96] <- 1
G[86,97] <- G[97,98:99] <- G[99,100] <- 1
# library(igraph)
# g0 = graph.adjacency(G,mode="undirected")
# tkplot(g0, layout=layout.kamada.kawai,vertex.label=rep('',p),vertex.size=5,
#              vertex.color="gray80", canvas.width=650, canvas.height=600 )
temp <- diag(0.5,p) + G*matrix(runif(p*p,0.5,1)*sample(c(-1,1),p*p,replace=TRUE),p,p)
temp2 <- temp + t(temp) + diag(rowSums(G+t(G))/2)
any(eigen(temp2,only.values=T)$values <= 0)
Omega0.true <- diag(diag(temp2)^-0.5) %*% temp2 %*% diag(diag(temp2)^-0.5)
# plot(sort(Omega0.true[Omega0.true != 0 & Omega0.true < 0.99]))
# add/subtract individual specific edges
A = diag(0,p); A[upper.tri(A)] = 1; A = A-G;
ind.0 <- which(A==1)
ind.1 <- which(G==1)
K = 8
Gk <- Omegas.true <- array(0,c(p,p,K))
dif.p <- 0.2
es <- 0.1
# Generating mechanism 1
for(k in 1:K) {
ind.ak <- sample(ind.0, round(sum(G)*dif.p))
ind.dk <- sample(ind.1, round(sum(G)*dif.p))
ind.sm <- setdiff(ind.1,ind.dk)
G.ak <- G.dk <- G.sm <- matrix(0,p,p)
G.ak[ind.ak] <- 1
G.dk[ind.dk] <- 1
G.sm[ind.sm] <- 1
temp.k = matrix(0,p,p)
while(any(eigen(temp.k)$values <= 0)) {
temp.ak <- G.ak*matrix(runif(p*p,0.5,1)*sample(c(-1,1),p*p,replace=TRUE),p,p)
temp.dk <- G.dk*temp
temp.sm <- G.sm*matrix(runif(p*p,0,es)*sample(c(-1,1),p*p,replace=TRUE),p,p)
temp.k <- temp + t(temp) - temp.dk - t(temp.dk) + temp.ak + t(temp.ak) + temp.sm + t(temp.sm) +
diag(rowSums(G+t(G)+G.ak+t(G.ak)-G.dk-t(G.dk))/2)
}
Omegas.true[,,k] <- diag(diag(temp.k)^-0.5) %*% temp.k %*% diag(diag(temp.k)^-0.5)
Gk[,,k] <- G + G.ak -G.dk
cat(k,"is done \n")
}
G.true <- G
Gk.true <- Gk
n <- 50
sim.dat <- rep(list(NA),K)
for(k in 1:K) sim.dat[[k]] <- matrix(rnorm(n*p),n,p) %*% chol(solve(Omegas.true[,,k]))
# parameters to tune: lambda1, lambda2, and lambda3
lam2.cand = 100 ; lam3.cand = 0.0001
lam1.cand = c(0.0002,0.0006,0.0008,seq(0.001,0.006,by=0.001),0.008,0.01,0.015,0.02)
lams.cand <- expand.grid(lam1.cand,lam2.cand,lam3.cand)
lam2.cand = 70 ; lam3.cand = 0.0001
lam1.cand = c(0.0002,0.0006,0.0008,seq(0.001,0.006,by=0.001),0.008,0.01,0.015,0.02)
lams.cand <- rbind(lams.cand,expand.grid(lam1.cand,lam2.cand,lam3.cand))
lam2.cand = 40 ; lam3.cand = 0.001
lam1.cand = c(0.0002,0.0006,0.0008,seq(0.001,0.006,by=0.001),0.008,0.01,0.015,0.02)
lams.cand <- rbind(lams.cand,expand.grid(lam1.cand,lam2.cand,lam3.cand))
colnames(lams.cand) <- c('lam1','lam2','lam3')
nlams <- nrow(lams.cand)
x <- sim.dat
K = length(x); p = ncol(x[[1]])
uptri.mat0 <- diag(0,p); uptri.mat0[upper.tri(diag(p))] <- 1
uptri.matk <- array(uptri.mat0,c(p,p,K))
Omega0.est <- array(NA,c(p,p,nlams))
Omegas.est <- array(NA,c(p,p,K,nlams))
bic.rc <- mbic.rc<- array(NA,nlams)
for(j in 1:2) {
# regularizing parameters
lam1 <- lams.cand[j,1]*(1+lams.cand[j,2])
lam2 <- lams.cand[j,2]*K;
lam3 <- lams.cand[j,3]
# estimation
est <- rand_cov(x,lam1,lam2,lam3)
Omega0 <- est$Omega0
Omegas <- est$Omegas
Omega0.est[,,j] <- Omega0
Omegas.est[,,,j] <- Omegas
# calculate BIC
bic.rc[j] <- bic_cal(x,Omegas)
mbic.rc[j] <- mbic_cal(x,Omega0,Omegas,lams.cand[j,2])
# keep track
if(j < nlams & lams.cand[j+1,2] != lams.cand[j,2]) cat('lam2 =',lams.cand[j,2],'is done \n')
}  # end of loop for all lambdas
for(j in 1:2) {
# regularizing parameters
lam1 <- lams.cand[j,1]*(1+lams.cand[j,2])
lam2 <- lams.cand[j,2]*K;
lam3 <- lams.cand[j,3]
# estimation
est <- rcm::randCov(x,lam1,lam2,lam3)
Omega0 <- est$Omega0
Omegas <- est$Omegas
Omega0.est[,,j] <- Omega0
Omegas.est[,,,j] <- Omegas
# calculate BIC
bic.rc[j] <- bic_cal(x,Omegas)
mbic.rc[j] <- mbic_cal(x,Omega0,Omegas,lams.cand[j,2])
# keep track
if(j < nlams & lams.cand[j+1,2] != lams.cand[j,2]) cat('lam2 =',lams.cand[j,2],'is done \n')
}  # end of loop for all lambdas
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
unlink('docs/exampleSimulationRCM_cache', recursive = TRUE)
