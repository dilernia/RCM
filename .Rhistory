lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
return(listRes)
}
parallel::stopCluster(cl)
View(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
return(listRes)
}
parallel::stopCluster(cl)
remove(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
return(listRes)
}
parallel::stopCluster(cl)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
})
return(listRes)
}
parallel::stopCluster(cl)
View(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
return(listRes)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
return(listRes)
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
return(listRes)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
return(listRes)
}
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
})
}
parallel::stopCluster(cl)
View(nets)
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 3, p = 5, n = 100, overlap = 0.50, rho = 0.10)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "RCM", G = 2)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "GLasso", G = 2)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "GLasso", G = 2, ncores = 3)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "FGL", G = 2)
View(optTune)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "FGL", G = 2, ncores = 3)
View(optTune)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "RCCM", G = 2)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "RCCM", G = 2, ncores = 3)
devtools::document()
?starsRccm
remove.packages("rcm")
?rccm
?starsRccm
devtools::document()
?starsRccm
devtools::document()
?starsRccm
remove.packages("rcm")
devtools::document()
?starsRccm
devtools::document()
remove.packages("rcm")
devtools::document()
remove.packages("rcm")
devtools::document()
?starsRccm
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 30,
lambda2 = 325, lambda3 = 0.10, nclusts = 2)
View(resultRccm)
resultRccm[["weights"]]
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 25,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
View(resultRccm)
resultRccm[["weights"]]
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
resultRccm[["weights"]]
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
View(resultRccm)
resultRccm[["weights"]]
# Calculate AIC and BIC
optTune <- aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbic
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbicm
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbicm(x = myData$simDat, omegaks = resultRccm$Omegas,
omega0s = resultRccm$Omega0, lambda2 = 325, ws = resultRccm$weights)
devtools::document()
?aicbicm
View(myData)
devtools::document()
?zToA
zToA(c(rep(1, 2), rep(2, 2), rep(3, 2)))
c(rep(1, 2), rep(2, 2), rep(3, 2))
remove.packages("rcm")
devtools::install_github("dilernia/rcm")
library(rcm)
?rcm
??rcm
getwd()
rccSim <- function(G = 2, clustSize = c(67, 37), p = 10,
n = 177, overlap = 0.50, rho = 0.10) {
# Calculating total number of subjects
K <- ifelse(length(clustSize) == 1, G * clustSize, sum(clustSize))
# Cluster Networks --------------------------------------------------------
g0s <- array(0, c(p, p, G))
gks <- array(0, c(p, p, K))
Omega0s <- array(0, c(p, p, G))
Omegaks <- array(0, c(p, p, K))
if (length(clustSize) > 1) {
zgks <- c()
for (g in 1:length(clustSize)) {
zgks <- c(zgks, rep(g, clustSize[g]))
}
} else {
zgks <- sort(rep(1:G, clustSize))
}
simDat <- list()
# Manually generating cluster-level graphs and precision matrices
# Number of hubs
J <- floor(sqrt(p))
# Function for dividing entries by corresponding row sums to make positive definite
symmPosDef <- function(m, rs = rowSums(g0s[, , g])) {
for (r in 1:nrow(m)) {
if (min(eigen(m + t(m))$values) <= 0) {
m[r, ] <- m[r, ] / max(c(rs[r], 2))
}
}
return(m + t(m))
}
# Determining edges to be shared across groups
numE <- p - J
numShare <- floor(numE * overlap)
eShare <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:(p * (p - 1) / 2), size = numShare), ], ncol = 2)
# Different graphs if balanced clusters or not
balanced <- ifelse(length(clustSize) > 1, "_unbal", "")
# Generating group-level graphs and precision matrices
while (min(apply(Omega0s, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (g in 1:G) {
# Keeping cluster-level graphs constant across simulations
if (file.exists(paste0("graphs_p", p, "_over", overlap, "_G",
G, balanced, ".rds")) == FALSE) {
g0s[, , g] <- matrix(0, nrow = p, ncol = p)
hubs <- split(sample.int(p, size = p, replace = FALSE), rep(1:J, ceiling(p / J))[1:p])
for (h in 1:J) {
for (v in hubs[[h]]) {
g0s[, , g][hubs[[h]][1], v] <- 1
}
}
# Adding in numShare shared edges
for (e in 1:nrow(eShare)) {
g0s[, , g][eShare[e, 1], eShare[e, 2]] <- 1
}
# Saving graphs to keep constant across simulations
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
if (g == G) {
saveRDS(g0s, paste0("graphs_p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
} else {
g0s <- readRDS(paste0("graphs_p", p, "_over", overlap, "_G", G, balanced, ".rds"))
}
# Making graph triangular for precision matrix generation and storing row edge count
g0s[, , g] <- (g0s[, , g] + t(g0s[, , g]) > 0.001) + 0
rwSum <- rowSums(g0s[, , g])
g0s[, , g][upper.tri(g0s[, , g], diag = T)] <- 0
Omega0s[, , g] <- g0s[, , g] * matrix(runif(n = p * p, min = 0.50, max = 1), nrow = p, ncol = p)
if (g > 1) {
for (e in 1:nrow(eShare)) {
Omega0s[, , g][eShare[e, 1], eShare[e, 2]] <- Omega0s[, , g - 1][eShare[e, 1], eShare[e, 2]]
}
}
# Making matrix symmetric and positive definite
Omega0s[, , g] <- symmPosDef(Omega0s[, , g], rs = rwSum)
diag(Omega0s[, , g]) <- 1
# Making graph full again, not just lower triangular
g0s[, , g] <- g0s[, , g] + t(g0s[, , g])
}
}
# Generating subject-level matrices
while (min(apply(Omegaks, MARGIN = 3, FUN = function(x) {
min(eigen(x)$values)})) <= 0) {
for (k in 1:K) {
# Creating subject-level graph to be exactly same as group-level graph for now
gks[, , k] <- matrix(0, nrow = p, ncol = p)
gks[, , k][lower.tri(gks[, , k], diag = FALSE)] <- g0s[, , zgks[k]][lower.tri(g0s[, , zgks[k]],
diag = FALSE)]
# Forcing subject-level matrix to have similar value as group-level matrix
Omegaks[, , k] <- gks[, , k] * (Omega0s[, , zgks[k]] + matrix(rnorm(n = p * p, sd = 0.05),
nrow = p, ncol = p))
# Changing edge presence for floor(0.10 * E) pairs of vertices from group-level graph
if (floor(rho * sum(gks[, , k])) > 0) {
# Determining which %10 of node pairs to change edge presence for
swaps <- matrix(which(lower.tri(matrix(1, p, p), diag = F),
arr.ind = TRUE)[sample(1:(p * (p - 1) / 2),
size = floor(rho * sum(gks[, , k]))), ], ncol = 2)
for (s in 1:nrow(swaps)) {
gks[, , k][swaps[s, 1], swaps[s, 2]] <- abs(gks[, , k][swaps[s, 1], swaps[s, 2]] - 1)
Omegaks[, , k][swaps[s, 1], swaps[s, 2]] <- ifelse(gks[, , k][swaps[s, 1], swaps[s, 2]] == 1,
runif(0.50, 1, n = 1), 0)
}
}
# Making graph symmetric
gks[, , k] <- gks[, , k] + t(gks[, , k])
# Making matrix symmetric and positive definite
Omegaks[, , k] <- symmPosDef(Omegaks[, , k])
diag(Omegaks[, , k]) <- 1
}
}
for (k in 1:K) {
# Generating subject data
simDat[[k]] <- mvtnorm::rmvnorm(n = n, sigma = solve(Omegaks[, , k]))
}
# Centering generated data
simDat <- lapply(simDat, FUN = scale, scale = FALSE)
results <- list(simDat = simDat, g0s = g0s, Omega0s = Omega0s,
Omegaks = Omegaks, zgks = zgks)
return(results)
}
?rccSim
myData <- rccSim(G = 2, clustSize = c(12, 10), p = 15, n = 100, overlap = 0.50, rho = 0.10)
library(mvtnorm)
install.packages('mvtnorm')
myData <- rccSim(G = 2, clustSize = c(12, 10), p = 15, n = 100, overlap = 0.50, rho = 0.10)
myData <- rccSim(G = 2, clustSize = c(12, 10), p = 50, n = 100, overlap = 0.50, rho = 0.10)
myData <- rccSim(G = 2, clustSize = c(12, 10), p = 100, n = 100, overlap = 0.50, rho = 0.10)
myData <- rccSim(G = 2, clustSize = c(12, 10), p = 100, n = 200, overlap = 0.50, rho = 0.10)
myData <- rccSim(G = 2, clustSize = c(2, 3), p = 100, n = 200, overlap = 0.50, rho = 0.10)
myData <- rccSim(G = 2, clustSize = c(2, 3), p = 500, n = 200, overlap = 0.50, rho = 0.10)
myData <- rccSim(G = 2, clustSize = c(2, 3), p = 500, n = 600, overlap = 0.50, rho = 0.10)
graphs_p100_over0.5_G2_unbal <- readRDS("C:/Users/goblu/Dropbox/Minnesota/fMRI Research/rcm/graphs_p100_over0.5_G2_unbal.rds")
graphs_p100_over0.5_G2_unbal[, , 1]
?huge::huge.generator
?rccSim
?rcm::rccSim
devtools::document()
?rcm::rccSim
devtools::document()
?rcm::rccSim
devtools::document()
?rcm::rccSim
devtools::document()
?rcm::rccSim
devtools::document()
devtools::document()
remove.packages('rcm')
devtools::install_github('dilernia/rcm')
devtools::document()
devtools::document()
devtools::document()
p <- 10; p * (p - 1) / 2
choose(p, 2)
devtools::document()
