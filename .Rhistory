arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "G", "K", "adj", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "adj", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "adj", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
View(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "adj", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
t = 1
arrayRes <- randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
return(listRes)
}
parallel::stopCluster(cl)
listRes <- NULL
try({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
})
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
return(listRes)
}
parallel::stopCluster(cl)
View(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
return(listRes)
}
parallel::stopCluster(cl)
remove(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
return(NA)
})
return(listRes)
}
parallel::stopCluster(cl)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
}
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
})
return(listRes)
}
parallel::stopCluster(cl)
View(nets)
cl <- parallel::makeCluster(ncores) # creates a cluster with <ncore> cores
doParallel::registerDoParallel(cl) # register the cluster
nets <- foreach::foreach(t = 1:nrow(lambs),
.export = c("method", "subDats", "G", "K", "lambs", "z0s")) %dopar% {
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t, "lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
return(listRes)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t, "lambda1"] / 100, penalize.diagonal = FALSE)$wi)})
return(listRes)
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method == "GGL", "group", "fused"),
penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50 / 1000,
return.whole.theta = TRUE)$theta, FUN = adj)
return(listRes)
} else if (method == "RCM") {
arrayRes <- rcm::randCov(x = subDats, lambda1 = lambs[t, "lambda1"] / 100,
lambda2 = lambs[t, "lambda2"] / 50,
lambda3 = lambs[t, "lambda3"] / 100000)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]}), FUN = adj)
return(listRes)
}
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ", lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ", lambs[t, "lambda3"]))
})
}
parallel::stopCluster(cl)
View(nets)
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 3, p = 5, n = 100, overlap = 0.50, rho = 0.10)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "RCM", G = 2)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "GLasso", G = 2)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "GLasso", G = 2, ncores = 3)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "FGL", G = 2)
View(optTune)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "FGL", G = 2, ncores = 3)
View(optTune)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "RCCM", G = 2)
optTune <- starsRccm(datf = myData$simDat, lambs = expand.grid(lambda1 = c(20, 25, 30),
lambda2 = c(300, 325), lambda3 = 0.01), method = "RCCM", G = 2, ncores = 3)
devtools::document()
?starsRccm
remove.packages("rcm")
?rccm
?starsRccm
devtools::document()
?starsRccm
devtools::document()
?starsRccm
remove.packages("rcm")
devtools::document()
?starsRccm
devtools::document()
remove.packages("rcm")
devtools::document()
remove.packages("rcm")
devtools::document()
?starsRccm
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 30,
lambda2 = 325, lambda3 = 0.10, nclusts = 2)
View(resultRccm)
resultRccm[["weights"]]
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 25,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
View(resultRccm)
resultRccm[["weights"]]
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
resultRccm[["weights"]]
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
View(resultRccm)
resultRccm[["weights"]]
# Calculate AIC and BIC
optTune <- aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbic
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbic
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbic(x = myData$simDat, omegaks = resultRccm$Omegas)
devtools::document()
?aicbicm
# Generate data
set.seed(1994)
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
# Analyze with RCCM
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
# Calculate AIC and BIC
aicbicm(x = myData$simDat, omegaks = resultRccm$Omegas,
omega0s = resultRccm$Omega0, lambda2 = 325, ws = resultRccm$weights)
devtools::document()
?aicbicm
View(myData)
devtools::document()
?zToA
zToA(c(rep(1, 2), rep(2, 2), rep(3, 2)))
c(rep(1, 2), rep(2, 2), rep(3, 2))
